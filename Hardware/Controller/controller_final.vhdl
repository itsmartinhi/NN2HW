-- Generated by vxx2ghdl
--
-- Generated by VASY
--
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY controller_final IS
PORT(
  clk	: IN STD_LOGIC;
  reset	: IN STD_LOGIC;
  in_ctrl_neuron_reset	: IN STD_LOGIC;
  in_ctrl_input_reset	: IN STD_LOGIC;
  c_dec_neuron	: OUT STD_LOGIC;
  c_dec_input	: OUT STD_LOGIC;
  c_add_to_neuron	: OUT STD_LOGIC;
  c_reset_register	: OUT STD_LOGIC;
  c_argmax	: OUT STD_LOGIC;
  halt	: OUT STD_LOGIC
);
END controller_final;

ARCHITECTURE RTL OF controller_final IS
  SIGNAL mbk_buf_not_state	: STD_LOGIC_VECTOR(0 DOWNTO 0);
  SIGNAL mbk_buf_state	: STD_LOGIC_VECTOR(0 DOWNTO 0);
  SIGNAL not_state	: STD_LOGIC_VECTOR(2 DOWNTO 0);
  SIGNAL state	: STD_LOGIC_VECTOR(2 DOWNTO 0);
  SIGNAL on12_x1_sig	: STD_LOGIC;
  SIGNAL not_reset	: STD_LOGIC;
  SIGNAL not_aux5	: STD_LOGIC;
  SIGNAL not_aux4	: STD_LOGIC;
  SIGNAL not_aux3	: STD_LOGIC;
  SIGNAL not_aux0	: STD_LOGIC;
  SIGNAL noa22_x1_sig	: STD_LOGIC;
  SIGNAL no3_x1_sig	: STD_LOGIC;
  SIGNAL no3_x1_2_sig	: STD_LOGIC;
  SIGNAL na3_x1_sig	: STD_LOGIC;
  SIGNAL na3_x1_2_sig	: STD_LOGIC;
  SIGNAL na2_x1_sig	: STD_LOGIC;
  SIGNAL na2_x1_2_sig	: STD_LOGIC;
  SIGNAL mbk_buf_not_aux0	: STD_LOGIC;
  SIGNAL mbk_buf_aux1	: STD_LOGIC;
  SIGNAL aux1	: STD_LOGIC;
  SIGNAL a2_x2_sig	: STD_LOGIC;
  SIGNAL a2_x2_2_sig	: STD_LOGIC;

  COMPONENT buf_x2
  PORT(
  i	: IN STD_LOGIC;
  q	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT no2_x1
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  nq	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT no3_x1
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  i2	: IN STD_LOGIC;
  nq	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT sff1_x4
  PORT(
  ck	: IN STD_LOGIC;
  i	: IN STD_LOGIC;
  q	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT a2_x2
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  q	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT na3_x1
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  i2	: IN STD_LOGIC;
  nq	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT na2_x1
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  nq	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT on12_x1
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  q	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT noa22_x1
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  i2	: IN STD_LOGIC;
  nq	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT inv_x2
  PORT(
  i	: IN STD_LOGIC;
  nq	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT o3_x2
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  i2	: IN STD_LOGIC;
  q	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT inv_x4
  PORT(
  i	: IN STD_LOGIC;
  nq	: OUT STD_LOGIC
   );
  END COMPONENT;

  COMPONENT o2_x2
  PORT(
  i0	: IN STD_LOGIC;
  i1	: IN STD_LOGIC;
  q	: OUT STD_LOGIC
   );
  END COMPONENT;

BEGIN
  mbk_buf_not_state_0 : buf_x2
  PORT MAP (
    i => not_state(0),
    q => mbk_buf_not_state(0)
  );
  i_mbk_buf_aux1 : buf_x2
  PORT MAP (
    i => aux1,
    q => mbk_buf_aux1
  );
  i_mbk_buf_not_aux0 : buf_x2
  PORT MAP (
    i => not_aux0,
    q => mbk_buf_not_aux0
  );
  mbk_buf_state_0 : buf_x2
  PORT MAP (
    i => state(0),
    q => mbk_buf_state(0)
  );
  c_dec_neuron_ins : buf_x2
  PORT MAP (
    i => mbk_buf_aux1,
    q => c_dec_neuron
  );
  c_dec_input_ins : no2_x1
  PORT MAP (
    i0 => mbk_buf_not_aux0,
    i1 => state(1),
    nq => c_dec_input
  );
  c_add_to_neuron_ins : no2_x1
  PORT MAP (
    i0 => not_aux5,
    i1 => state(2),
    nq => c_add_to_neuron
  );
  c_reset_register_ins : buf_x2
  PORT MAP (
    i => mbk_buf_aux1,
    q => c_reset_register
  );
  c_argmax_ins : no2_x1
  PORT MAP (
    i0 => not_aux4,
    i1 => not_state(2),
    nq => c_argmax
  );
  halt_ins : no3_x1
  PORT MAP (
    i0 => not_state(2),
    i1 => state(1),
    i2 => mbk_buf_not_state(0),
    nq => halt
  );
  state_0_ins : sff1_x4
  PORT MAP (
    ck => clk,
    i => a2_x2_2_sig,
    q => state(0)
  );
  a2_x2_2_ins : a2_x2
  PORT MAP (
    i0 => na3_x1_2_sig,
    i1 => not_reset,
    q => a2_x2_2_sig
  );
  na3_x1_2_ins : na3_x1
  PORT MAP (
    i0 => not_aux5,
    i1 => not_state(2),
    i2 => na2_x1_2_sig,
    nq => na3_x1_2_sig
  );
  na2_x1_2_ins : na2_x1
  PORT MAP (
    i0 => in_ctrl_neuron_reset,
    i1 => state(1),
    nq => na2_x1_2_sig
  );
  state_1_ins : sff1_x4
  PORT MAP (
    ck => clk,
    i => a2_x2_sig,
    q => state(1)
  );
  a2_x2_ins : a2_x2
  PORT MAP (
    i0 => na3_x1_sig,
    i1 => not_reset,
    q => a2_x2_sig
  );
  na3_x1_ins : na3_x1
  PORT MAP (
    i0 => not_aux4,
    i1 => not_aux3,
    i2 => on12_x1_sig,
    nq => na3_x1_sig
  );
  on12_x1_ins : on12_x1
  PORT MAP (
    i0 => aux1,
    i1 => in_ctrl_neuron_reset,
    q => on12_x1_sig
  );
  state_2_ins : sff1_x4
  PORT MAP (
    ck => clk,
    i => no3_x1_sig,
    q => state(2)
  );
  no3_x1_ins : no3_x1
  PORT MAP (
    i0 => no3_x1_2_sig,
    i1 => noa22_x1_sig,
    i2 => na2_x1_sig,
    nq => no3_x1_sig
  );
  no3_x1_2_ins : no3_x1
  PORT MAP (
    i0 => in_ctrl_neuron_reset,
    i1 => not_state(1),
    i2 => state(2),
    nq => no3_x1_2_sig
  );
  noa22_x1_ins : noa22_x1
  PORT MAP (
    i0 => state(2),
    i1 => state(1),
    i2 => mbk_buf_state(0),
    nq => noa22_x1_sig
  );
  na2_x1_ins : na2_x1
  PORT MAP (
    i0 => not_reset,
    i1 => not_aux3,
    nq => na2_x1_sig
  );
  aux1_ins : no2_x1
  PORT MAP (
    i1 => not_aux0,
    i0 => not_state(1),
    nq => aux1
  );
  not_reset_ins : inv_x2
  PORT MAP (
    i => reset,
    nq => not_reset
  );
  not_state_2_ins : inv_x2
  PORT MAP (
    i => state(2),
    nq => not_state(2)
  );
  not_state_1_ins : inv_x2
  PORT MAP (
    i => state(1),
    nq => not_state(1)
  );
  not_aux3_ins : o3_x2
  PORT MAP (
    i0 => in_ctrl_input_reset,
    i1 => state(1),
    i2 => state(2),
    q => not_aux3
  );
  not_state_0_ins : inv_x4
  PORT MAP (
    i => state(0),
    nq => not_state(0)
  );
  not_aux0_ins : o2_x2
  PORT MAP (
    i0 => state(2),
    i1 => not_state(0),
    q => not_aux0
  );
  not_aux4_ins : o2_x2
  PORT MAP (
    i0 => mbk_buf_state(0),
    i1 => state(1),
    q => not_aux4
  );
  not_aux5_ins : o2_x2
  PORT MAP (
    i0 => mbk_buf_state(0),
    i1 => not_state(1),
    q => not_aux5
  );
END RTL;



-- Configuration for sxlib/VITAL library...
library sxlib;
use sxlib.vcomponents.all;

configuration CFG_controller_final of controller_final is
  for RTL
    for all: buf_x2 use entity sxlib.buf_x2(vital); end for;
    for all: no2_x1 use entity sxlib.no2_x1(vital); end for;
    for all: no3_x1 use entity sxlib.no3_x1(vital); end for;
    for all: sff1_x4 use entity sxlib.sff1_x4(vital); end for;
    for all: a2_x2 use entity sxlib.a2_x2(vital); end for;
    for all: na3_x1 use entity sxlib.na3_x1(vital); end for;
    for all: na2_x1 use entity sxlib.na2_x1(vital); end for;
    for all: on12_x1 use entity sxlib.on12_x1(vital); end for;
    for all: noa22_x1 use entity sxlib.noa22_x1(vital); end for;
    for all: inv_x2 use entity sxlib.inv_x2(vital); end for;
    for all: o3_x2 use entity sxlib.o3_x2(vital); end for;
    for all: inv_x4 use entity sxlib.inv_x4(vital); end for;
    for all: o2_x2 use entity sxlib.o2_x2(vital); end for;
  end for;
end CFG_controller_final;
